## 基本信息

* 题目名称： [GDOUCTF 2023]受不了一点
* 题目链接： https://www.nssctf.cn/problem/3727
* 考点清单： 弱比较，强比较，hash 函数，PHP，数组绕过
* 工具清单： PHP环境，hackbar
* payloads：比较绕过

## 一、看到什么

**题目关键信息列表**：

1. `PHP 源代码`: 该题的`PHP` 源码，本题的唯一线索。


## 二、想到什么解题思路

1. 源码审计：

   - 题目意思很明确，按照条件判断的指示，构造一层层的参数进行绕过，最终进入到`echo $flag; `。

## 三、尝试过程和结果记录

**代码解读：**

- `if($_POST['gdou']!=$_POST['ctf'] && md5($a)===md5($b))`这是md5的强比较，可以通过数组进行绕过。数组的md5值都是`Null`,满足强比较。

- `if ($_COOKIE['cookie']=='j0k3r')`设置`cookie`值为相应值即可。

- `if($aaa==114514 && $bbb==114514 && $aaa!=$bbb)`这也属于php的弱比较，当字符串与数字进行比较时，字符串会转换为对应类型的数字进行比较。

- `if(isset($_GET['flag']) && isset($_POST['flag']))`和`if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag')`

    - 前者的意思是同时设置了`GET`和`POST`的名为`flag`的参数
    - 后者的意思是这两个参数存在任意值为`flag`
    - 两者满足其一，就会输出终止错误信息。
    - 但是我们要注意的是，我们要输出最终的`flag`，是【不要去】满足这里的两个条件的！

**尝试过程：**

1. 尝试构造`$a`和`$b`绕过第二个`if`条件，进入`if`块内：

    可以通过数组绕过，本地进行测试。

   ```php
    <?php
    $a[]=1;
    $b[]=2;


    if( ($a != $b) && (md5($a) === md5($b)) && (sha1($a)=== sha1($b)) && md5($a) == null && sha1($a) == null){
        echo "success!";
    }

    ?>
   ```
    输出`success!`表明两个数组本身不相等，同时它们的`md5`和`sha1`值都为`null`，并且相等。

2. 设置`cookie`，使用`hackbar`或者是`yakit`工具。

3. 构造`$aaa`和`$bbb`进行绕过，这也是弱比较的特性，字符串与数字比较时，会将字符串进行转化，可以通过本地验证。
    - 设置`$aaa='114514'`和`$bbb='114514a'`,那么他们与114514的比较，就是字符串与数字的比较，则`$aaa`和`$bbb`都转化为数字`114514`，两个参数自己的比较则是字符串的比较，自然是不相等的。

    ```php
        <?php
        $aaa='114514';
        $bbb='114514a';


        if($aaa==114514 && $bbb==114514 && $aaa!=$bbb){
            echo "success!";
        }

        ?>
    ```
    

4. 我们不需要满足`$_GET['flag']`和`$_POST['flag']`的条件，这可能是障眼法，不能看到就往里面钻。

5. 构造完整`payloads`

![payloads](images/[GDOUCTF%202023]受不了一点-payloads.png)

## 四、总结与反思

1. PHP弱比较、强比较特性：

   **`==`（等于）、`!=`（不等）**：比较 **值是否相等**，会 **自动转换类型**（类型转换后再进行比较）；

   **`===`（全等，严格相等）、`!==`（不全等，严格不等）**：比较 **值和类型是否完全相等**，不会进行 **类型转换**，同时比较值和类型。

2. 数组的`md5`值和`sha1`值为`null`，但是两个数组进行强比较时仍然相等。